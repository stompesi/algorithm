```
이 글은 백준온라인(https://www.acmicpc.net/)의 문제를 공부한 내용입니다.
문제번호: 2998
문제이름: 8진수
```

## 진법 변환

**N진수를 M진수로** 변환하는 방법은 보통 N진수를 10진수로 변환후 다시 10진수를 M진수로 변경하면 된다. 하지만 이 문제는 **2진수를 8진수**로 변경하는 방법을 이야기한다.이 때 2진수의 값을 3-bit씩 나누어 1-bit로 변경하여 처리가 가능하다.

예를들면, 1111(15)를 8진수로 변경해보자. 

1. 3-bit를 나누어보면 1 / 111로 나뉜다.

2. 각각의 bit를 10진수로 변환하면 끝이난다.

   - 10진수로 만드는 방법은 bit가 1일때 각자리수에 맞게 곱해주면 된다. 
     예를 들어, 101 = $1 * 2^2 + 0 * 2^1 + 1 * 2^0$으로 만들어 준다.

   ​

이제 문제를 풀면 코드를 보면 다음과 같다. (전체 코드는 : 참조)

```java
import java.util.Scanner;

public class Main2998 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		StringBuilder sb = new StringBuilder();
		String line = sc.nextLine();
		
		int remainder = line.length() % 3;
		int portion = line.length() / 3;
		int index = 0;
		int number = 0;
		
		if(remainder != 0) {
			for(int i = 0 ; i < remainder ; i++) {
				number *= 2;
				number += line.charAt(index++) - '0';
			}
			sb.append(number);
		}
		
		for(int i = 0 ; i < portion ; i++) {
			number = 0;
			for(int j = 0 ; j < 3 ; j++) {
				number *= 2;
				number += line.charAt(index++) - '0';
			}
			sb.append(number);
		}
		
		System.out.println(sb);
	}
}
```



```java
int remainder = line.length() % 3;
int portion = line.length() / 3;
```

- `remainder`의 역할은 2진수의 앞자리수는 나타낸다. 8진수로 바꾸려면 각각의 bit가 3bit로 와야 하지만 앞자리에는 bit가 0개, 1개, 2개 또는 3개가 올 수 있기 때문에 3개를 나눈 나머지가 앞자리의 오는 bit의 수가 된다.(나머지는 다 3-bit로 나뉜다)



```java
if(remainder != 0) {
	...
}
```

- `remainder`가 0이 되었을 때는 모든 bit가 3-bit씩 표현된다는 의미여서 앞자리수를 표현할 필요는 없다. 
  (if문으로 제외 시킴) 



```java
number = 0;
for(int j = 0 ; j < 3 ; j++) {
	number *= 2;
	number += line.charAt(index++) - '0';
}
sb.append(number);
```

- `number *= 2;`와  `number += line.charAt(index++) - '0';` 는 각 자리에 bit 값을 환산해주는 작업이다.




**시간 복잡도 계산**

- 코드를 보면 이중포문(보통은 O($n^2$))으로 보이지만 시간복잡도는 ==O(n)==이다.
- 문제에 제시한 입력은 2진수는 `100자리 이내이고,`이다. 따라서 최대 연산은 100번 (100ms)


Tip. 100,000,000번의 연산은 약 1초의 시간이 소요된다. 따라서 100,000번의 연산은 1ms, 100번의 연산은 1$\mu$s가 소요된다.


