```
이 글은 백준온라인(https://www.acmicpc.net/)의 문제를 공부한 내용입니다.
문제번호: 2805
문제이름: 나무 자르기
```

## 나무 자르기

이 문제에서 우리가 구해야하는 것은 나무를 최대한 보존하면서 원하는 나무의 길이를 가져갈 수 있도록 하는 **절단기의 최대 높이(h)**이다. 여기서 이분 탐색이 왜나올까? 

쉽게 풀려면 절단기의 높이를 1씩올려가면서 나무를 자르고 가져가는 나무의 길이를 구하여 가장 적절한 높이를 취할 수 있다. 이렇게 하면 시간복잡도는 **O(나무의 수 * 나무의 최대 높이)** 만큼을 잘라야 한다. 하지만 문제에 주어진 데이터의 범위를 보면 나무의수는 100만이고 나무의 최대 높이는 20억이다. 따라서 최악의 경우 100만 * 20억 = 2천조의 연산(2천만초)이 필요하므로 시간초과가 날 것이다.

따라서 우리는 이분 탐색으로 연산의 횟수를 줄여야 한다. 그럼 간단하게 이분탐색의 의미를 보고 넘어가자**이분탐색**이란 정렬된 데이터의 집합을 이분화 하면서 탐색하는 방법을 의미한다. 

우리는 탐색의 범위가 절단기의 높이(정렬된 데이터)를 **0 ~ 나무의 최대 높이**로 설정하고 구하려고 하는 절단기의 최대 높이가 탐색의 결과로 설정하여 문제를 풀 수있는 것이다. 

1. 절단기 높이의 범위 : 0 ~ 나무의 최대 높이가 된다. 
2. 이분법으로 검색을 진행한다
   1. 높이 범위의 절반을 기준으로 모든 나무를 자르고 나무의 길이를 모두 합한다
   2. 합친 나무의 길이가 주어진 값(가져가려고 하는 나무의 길이)보다  크면 절단기 높이의 범위를 변경한다.(정답 가능성 있음)
      절단기 높이의 범위 : 높이 범위의 절반 + 1 ~ 끝
      또한 절단기의 높이가 가장 큰것을 정답으로 설정한다
   3. 합친 나무의 길이가 주어진 값(가져가려고 하는 나무의 길이)보다 작으면 절단기 높이의 범위를 변경한다.(정답 가능성 없음)
      절단기 높이의 범위 : 시작 ~ 높이 범위의 절반 - 1
   4. 합친 나무의 길이가 주어진 값(가져가려고 하는 나무의 길이)이 같으면 그것이 정답이다.
3. 절단기 높이의 범위가 교차(시작이 끝보다 커지는 순간)하거나 정답을 구할때까지 반복한다.

예제의 입력을 통해 보면

```
4 7
20 15 10 17

------------
절단기높이(가져가는 나무의 길이)	시작 끝
------------
1. 10(22)	0 20  (정답 가능성 O)
2. 15(7)	11 20 (정답 !)
------------
```

여기서 우리는 가져가려고하는 나무의 길이보다 자른 나무의 길이가 크다면 절단기 높이를 높이고, 작다면 절단기 높이를 낮춰야 한다. 이유는 절단기 높이가 높아지면 잘리는 나무의 길이가 줄어들고, 절단기 높이가 낮아지면 잘리는 나무의 길이가 커지기 때문이다.

이분탐색으로 계산을 할 경우 시간복잡도는 **O(나무의 수 * log(나무의 최대 높이))**가 되므로 100만 * 약 31번 = 3천 1백만의 연산(0.31초)만으로 계산 할 수 있다.



전체 코드는 다음과 같다.

```java
import java.util.Scanner;

public class Main {
	
	static long getLength(long[] trees, int n, long mid) {
		long length = 0;
		for(int i = 0 ; i < n ; i++) {
			length += trees[i] - mid >= 0 ? trees[i] - mid : 0;
		}
		return length;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		long m = sc.nextLong();
		long[] trees = new long[n];
		
		long start = 0;
		long end = 0;
		long result = 0;
		
		for(int i = 0 ; i < n ; i ++) {
			trees[i] = sc.nextInt();
			end = Math.max(end, trees[i]);
		}
		
		while(start <= end) {
			long mid = (start + end) / 2;
			long length = getLength(trees, n, mid);
			
			if(length > m) {
				result = Math.max(result, mid);
				start = mid + 1;
			} else if(length == m) {
				result = mid;
				break;
			} else {
				end = mid - 1;
			}
		}
		System.out.println(result);
	}
}
```